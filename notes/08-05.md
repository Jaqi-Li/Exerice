
### 08-05:

***字符串复制产生的问题（已解决）:对于调用函数时传入的两个字符串：***
+ Clion使用Debug-vs编译器：

1. 数组形式将a复制给b 由于a数组长度比b数组长度长，导致b溢出

   系统执行时会报错
```c

char a[] = "test5";
char b[] = "qwe4";
stringCopy(a,b);

```
2. 指针形式将a复制给b 当b长度小于a时也会导致溢出

   系统执行时不报错,但会污染内存，使代码不能正常执行

   根据执行结果：stringCopy(a,b)后的代码被污染。
```c
char *a ="test5qwewq";
char *b = "q";
/**************************************************/
/* 
 * printf("%s\n",b);
 * stringCopy(a,b);
 * printf("===========================\n");
 * printf("===========================\n");
 * printf("===========================\n");
 * printf("%s\n",b);
 *
 * 执行结果：    
 * q
 * wq===========================
 * ===========================
 * test5qwewq
 */
/**************************************************/
```

+ VS编译器：

1. 数组形式将a复制给b 由于a数组长度比b数组长度长，导致b溢出

   系统执行时会报错
```c

char a[] = "test5";
char b[] = "qwe4";
stringCopy(a,b);

```
2. 指针形式将a复制给b

   a和b指向的字符串常量存储在常量存储区中，常量存储区中存储的都是常量不能修改。因此无法修改b指针指向的内存。

   系统执行时不报错，只打印qewq

   调试时对b指针修改时出错：*b = *a
```c
char *a ="test5qwewq";
char *b = "q";
/**************************************************/
/* 
 * printf("%s\n",b);
 * stringCopy(a,b);
 * printf("===========================\n");
 * printf("===========================\n");
 * printf("===========================\n");
 * printf("%s\n",b);
 *
 * 执行结果：    
 * qewq
 */
/**************************************************/
```

3. 指针形式a复制给字符数组b

   当a比b长时同1一样执行报错

   a比b短时正常运行。

```c
char *a ="test5";
char b[] = "qqwer";
```


***对使用字符指针变量和字符数组的讨论***
> 1. 字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的时地址（字符串第一个字符的地址），决不是将字符串放到字符指针变量中。
> 2. 赋值方式：对字符数组只能对各个元素赋值，不能用以下办法对字符数组赋值。
> ```c
> char str[20];
> str = "I love ly";
> ```
> 而对字符指针变量，可以采用下面方法赋值：
> ```c
> char * a;
> a = "I love ly";
> ```
> 3. 对字符指针变量赋初值
> ```c
> char * a = "I love ly"; //等价于
> char * a;
> a = "I love ly";
> ```
> 而对于数组的初始化
> ```c
> char str[20] = {"I love ly"};// 不等价于
> char str[20];
> str = "I love ly";
> ```